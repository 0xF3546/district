package de.district.core.character.domain;

import de.district.api.entity.PlayerCharacter;
import de.district.core.character.domain.dto.CharacterDto;
import de.district.core.character.util.Gender;
import de.district.core.character.util.LocalDateTimeAttributeConverter;
import de.district.core.faction.domain.Faction;
import de.district.core.faction.domain.FactionRank;
import de.district.core.user.domain.User;
import de.splatgames.generators.annotation.dto.Dto;
import de.splatgames.validations.valids.api.Validations;
import jakarta.persistence.Column;
import jakarta.persistence.Convert;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToOne;
import jakarta.persistence.Table;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;
import org.hibernate.proxy.HibernateProxy;
import org.jetbrains.annotations.NotNull;

import java.time.LocalDateTime;
import java.util.Objects;

/**
 * Represents the main entity for a character within the system.
 * <p>
 * The {@code Character} class manages characters in the application. Each character is uniquely
 * associated with a {@code User} and contains details such as their name, gender, date of birth,
 * and timestamps for creation.
 * </p>
 * <p>
 * This class is annotated with JPA and Lombok annotations for entity mapping and simplifying getters, setters,
 * and basic boilerplate code.
 * </p>
 *
 * @author Erik Pf√∂rtner
 * @see CharacterDto
 * @see User
 * @since 1.0.0
 */
@NoArgsConstructor
@Getter
@Setter
@ToString
@Entity
@Table(name = "characters")
public class Character implements PlayerCharacter {
    /**
     * The unique identifier for the character.
     * <p>
     * This field is auto-generated by the database and uniquely identifies each
     * {@code Character} entity.
     * </p>
     */
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(nullable = false)
    private Long id;

    /**
     * The {@link User} entity associated with this {@code Character}.
     * <p>
     * Each character has a unique relationship with a {@code User}, ensuring
     * one-to-one mapping. The user's ID serves as the foreign key.
     * </p>
     */
    @Dto(order = 1)
    @OneToOne
    @JoinColumn(name = "user_id", referencedColumnName = "id", nullable = false, unique = true)
    private User user;

    /**
     * The first name of the character.
     * <p>
     * This field represents the character's given name and is a required attribute.
     * </p>
     */
    @Dto(order = 2)
    @Column(name = "first_name", nullable = false)
    private String firstName;

    /**
     * The last name of the character.
     * <p>
     * This field represents the character's family name and is a required attribute.
     * </p>
     */
    @Dto(order = 3)
    @Column(name = "last_name", nullable = false)
    private String lastName;

    /**
     * The gender of the character.
     * <p>
     * This field uses the {@link Gender} enumeration to represent the character's gender
     * and is stored as a string in the database.
     * </p>
     */
    @Dto(order = 4)
    @Column(name = "gender", nullable = false)
    @Enumerated(EnumType.STRING)
    private Gender gender;

    /**
     * The date of birth of the character.
     * <p>
     * This field is stored as a {@link LocalDateTime} object and uses a custom
     * converter provided by {@link LocalDateTimeAttributeConverter}.
     * </p>
     */
    @Dto(order = 5)
    @Column(name = "dob", nullable = false)
    @Convert(converter = LocalDateTimeAttributeConverter.class)
    private LocalDateTime dob;

    /**
     * The creation timestamp of the character.
     * <p>
     * This field is automatically set when the character entity is created. It uses
     * a custom converter for proper handling in the database.
     * </p>
     */
    @Dto(order = 6)
    @Column(name = "created_at", nullable = false)
    @Convert(converter = LocalDateTimeAttributeConverter.class)
    private LocalDateTime createdAt;

    @Dto(order = 7)
    @OneToOne
    @JoinColumn(name = "faction_id", referencedColumnName = "id", nullable = true)
    private Faction factionId;

    @Dto(order = 8)
    @OneToOne
    @JoinColumn(name = "factionRank_id", referencedColumnName = "id", nullable = true)
    private FactionRank factionRank;

    @Dto(order = 9)
    @Column(name = "isLeader")
    private boolean isLeader;

    /**
     * Constructs a new {@code Character} instance from the provided {@link CharacterDto}.
     *
     * @param characterDto the data transfer object containing character details
     * @throws IllegalArgumentException if the provided {@code characterDto} is {@code null}
     */
    public Character(final CharacterDto characterDto) {
        change(characterDto);
    }

    /**
     * Updates the current {@code Character} instance with values from the provided {@link CharacterDto}.
     *
     * @param characterDto the data transfer object containing updated character details
     * @throws IllegalArgumentException if the {@code characterDto} is {@code null}
     */
    public void change(final CharacterDto characterDto) {
        Validations.assertThat(characterDto).isNotNull();

        this.user = characterDto.getUser();
        this.firstName = characterDto.getFirstName();
        this.lastName = characterDto.getLastName();
        this.gender = characterDto.getGender();
        this.dob = characterDto.getDob();
        this.createdAt = characterDto.getCreatedAt();
    }

    /**
     * Builds a new {@link CharacterDto} using the current {@code Character} instance's properties.
     *
     * @return a {@code CharacterDto} containing the character's details
     */
    public CharacterDto buildCharacterDto() {
        return new CharacterDto(this.user,
                this.firstName,
                this.lastName,
                this.gender,
                this.dob,
                this.createdAt);
    }

    /**
     * Compares this {@link Character} entity to another object for equality.
     *
     * <p>This method ensures that equality is based on the user's unique identifier, and it handles cases where
     * the entity is a proxy object generated by Hibernate.</p>
     *
     * @param o the object to compare to.
     * @return {@code true} if the objects are considered equal, {@code false} otherwise.
     */
    @Override
    public final boolean equals(final Object o) {
        if (this == o) return true;
        if (o == null) return false;
        Class<?> oEffectiveClass = o instanceof HibernateProxy ? ((HibernateProxy) o).getHibernateLazyInitializer().getPersistentClass() : o.getClass();
        Class<?> thisEffectiveClass = this instanceof HibernateProxy ? ((HibernateProxy) this).getHibernateLazyInitializer().getPersistentClass() : this.getClass();
        if (thisEffectiveClass != oEffectiveClass) return false;
        Character character = (Character) o;
        return getId() != null && Objects.equals(getId(), character.getId());
    }

    /**
     * Returns the hash code for this {@link Character} entity.
     *
     * <p>The hash code is generated based on the class's unique identifier and handles cases where the entity
     * is a proxy object generated by Hibernate.</p>
     *
     * @return the hash code of this entity.
     */
    @Override
    public final int hashCode() {
        return this instanceof HibernateProxy ? ((HibernateProxy) this).getHibernateLazyInitializer().getPersistentClass().hashCode() : getClass().hashCode();
    }

    /**
     * Retrieves the date of birth.
     *
     * @return The date of birth as a {@link LocalDateTime} object.
     */
    @Override
    public @NotNull LocalDateTime getDateOfBirth() {
        return this.dob;
    }
}
