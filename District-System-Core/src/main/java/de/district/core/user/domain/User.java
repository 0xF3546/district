package de.district.core.user.domain;

import de.district.core.user.domain.dto.UserDto;
import de.splatgames.generators.annotation.dto.Dto;
import de.splatgames.validations.valids.api.Validations;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;
import org.hibernate.proxy.HibernateProxy;

import java.util.Objects;

/**
 * The {@code User} class represents a user entity in the system, which is mapped to the {@code users} table in the database.
 * This class is designed to store and manage user-related data, such as UUID, creation time, region, and deactivation status.
 * It provides functionality to convert between the {@link User} entity and the {@link UserDto} data transfer object (DTO).
 *
 * <p>The {@code User} class is annotated with Lombok annotations to generate boilerplate code such as getters, setters,
 * a no-argument constructor, and a {@code toString} method. It is also annotated as an {@link Entity} and is associated with
 * the {@code users} table in the database using JPA annotations.</p>
 *
 * @see UserDto
 * @see Entity
 * @see Getter
 * @see Setter
 * @since 1.0.0
 * @author Erik Pf√∂rtner
 */
@NoArgsConstructor
@Getter
@Setter
@ToString
@Entity
@Table(name = "users")
public class User {

    /**
     * The unique identifier for the user, which is generated automatically.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(name = "id", nullable = false)
    private Long id;

    /**
     * The unique UUID of the user. This field is annotated with {@link Dto} to ensure it is included in the corresponding DTO.
     */
    @Dto(order = 1)
    @Column(name = "uuid", unique = true, nullable = false)
    private String uuid;

    /**
     * The timestamp representing when the user was created. This field is required and is included in the corresponding DTO.
     */
    @Dto(order = 2)
    @Column(name = "created_at", nullable = false)
    private long createdAt;

    /**
     * The region associated with the user. This field is required and is included in the corresponding DTO.
     */
    @Dto(order = 3)
    @Column(name = "region", nullable = false)
    private String region;

    /**
     * The deactivation status of the user. This field is required and is included in the corresponding DTO.
     */
    @Dto(order = 4)
    @Column(name = "deactivated", nullable = false)
    private boolean deactivated;

    /**
     * Constructs a new {@link User} entity based on the provided {@link UserDto}.
     *
     * @param userDto the data transfer object containing the user's data.
     */
    public User(final UserDto userDto) {
        change(userDto);
    }

    /**
     * Updates the current {@link User} entity with data from the provided {@link UserDto}.
     *
     * <p>This method performs validation to ensure that the {@code userDto} is not null before updating the fields.</p>
     *
     * @param userDto the data transfer object containing the updated user data.
     * @throws NullPointerException if {@code userDto} is {@code null}.
     */
    public void change(final UserDto userDto) {
        Validations.assertThat(userDto).isNotNull();

        this.uuid = userDto.getUuid();
        this.createdAt = userDto.getCreatedAt();
        this.region = userDto.getRegion();
        this.deactivated = userDto.isDeactivated();
    }

    /**
     * Builds and returns a {@link UserDto} based on the current state of the {@link User} entity.
     *
     * @return a new {@link UserDto} containing the user's data.
     */
    public UserDto buildUserDto() {
        return new UserDto(this.uuid,
                this.createdAt,
                this.region,
                this.deactivated);
    }

    /**
     * Compares this {@link User} entity to another object for equality.
     *
     * <p>This method ensures that equality is based on the user's unique identifier, and it handles cases where
     * the entity is a proxy object generated by Hibernate.</p>
     *
     * @param o the object to compare to.
     * @return {@code true} if the objects are considered equal, {@code false} otherwise.
     */
    @Override
    public final boolean equals(final Object o) {
        if (this == o) return true;
        if (o == null) return false;
        Class<?> oEffectiveClass = o instanceof HibernateProxy ? ((HibernateProxy) o).getHibernateLazyInitializer().getPersistentClass() : o.getClass();
        Class<?> thisEffectiveClass = this instanceof HibernateProxy ? ((HibernateProxy) this).getHibernateLazyInitializer().getPersistentClass() : this.getClass();
        if (thisEffectiveClass != oEffectiveClass) return false;
        User user = (User) o;
        return getId() != null && Objects.equals(getId(), user.getId());
    }

    /**
     * Returns the hash code for this {@link User} entity.
     *
     * <p>The hash code is generated based on the class's unique identifier and handles cases where the entity
     * is a proxy object generated by Hibernate.</p>
     *
     * @return the hash code of this entity.
     */
    @Override
    public final int hashCode() {
        return this instanceof HibernateProxy ? ((HibernateProxy) this).getHibernateLazyInitializer().getPersistentClass().hashCode() : getClass().hashCode();
    }
}
